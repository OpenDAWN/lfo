!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.draw=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/* Generated by es6-transpiler 0.7.14-2 */ 
"use strict";

var Lfp = _dereq_('lfp');

var Draw = (function(super$0){var DP$0 = Object.defineProperty;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,Object.getOwnPropertyDescriptor(s,p));}}return t};MIXIN$0(Draw, super$0);

  function Draw() {var previous = arguments[0];if(previous === void 0)previous = null;var options = arguments[1];if(options === void 0)options = {};
    if (!(this instanceof Draw)) return new Draw(previous, options);
    
    // defaults
    options = this.extend({
      scroll: true,
      color: '#000000'
    }, options);

    super$0.call(this, previous, options);
    
    if(!options.canvas) return console.error('Please note: a canvas element is required or this module');
    
    // sets member properties with default encapsulation
    this.declareMembers([
      "buffCtx",
      "cvCtx",
      "width",
      "height",
      "amp",
      "x",
      "i",
      "rate",
      "minVal",
      "maxVal",
      { buffer: {value: document.createElement("canvas")} }
    ]);
    
    this.type = 'draw';//require('./package.json').name;
    this.scrolls = options.scroll;
    this.canvas = options.canvas;

    this.buffer.width = this.canvas.width;
    this.buffer.height = this.canvas.height;

    this.buffCtx = this.buffer.getContext('2d');
    this.cvCtx = this.canvas.getContext('2d');

    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.amp = this.height / 2;

    this.x = 0;
    this.i = 0;
    this.rate = 0.1;

    this.minVal = -1.0;
    this.maxVal = 1.0;

    this.color = options.color;
  }Draw.prototype = Object.create(super$0.prototype, {"constructor": {"value": Draw, "configurable": true, "writable": true} });DP$0(Draw, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  Draw.prototype.clearCanvas = function(cv) { 
    cv.height = this.height; cv.width = this.width;
  }

  Draw.prototype.scrollLeft = function() {

    // clear the buffer
    this.clearCanvas(this.buffer);
    // draw the destination into the buffer at 0 0
    this.buffCtx.drawImage(this.canvas, 0, 0);

    // clear the destination
    this.clearCanvas(this.canvas);
    // save the destination state
    this.cvCtx.save();
    // translate destination by 1 px on x
    this.cvCtx.translate(-1, 0);
    // draw the buffer into the destination
    this.cvCtx.drawImage(this.buffer, 0, 0);
    // restore the destination
    this.cvCtx.restore();

    // re-set the index
    this.x = this.width - 1;
  }


  Draw.prototype.process = function(time, data) {

    var min = this.maxVal;
    var max = this.minVal;
    var step = data.length;

    if(this.scrolls && (this.i % 4 === 0)){

      for (var j = 0; j < step; j++) {
        var datum = data[j];
        if (datum < min) min = datum;
        if (datum > max) max = datum;
      }

      var pos = (1 - max * this.amp) + this.amp;
      var h = (max - min) * this.amp;

      this.cvCtx.fillStyle = this.color;
      this.cvCtx.fillRect(this.x, pos, 1, Math.max(1, h));
      
      this.x++;
      if(this.x >= this.width) this.scrollLeft();
    }
    
    this.i++;
  }

;return Draw;})(Lfp);

module.exports = Draw;
},{"lfp":2}],2:[function(_dereq_,module,exports){
/* Generated by es6-transpiler 0.7.14-2 */ 
"use strict";

function isObject(item){
  return typeof item === 'object';
}

var Lfp = (function(){var DP$0 = Object.defineProperty;

  function Lfp() {var previous = arguments[0];if(previous === void 0)previous = null;var options = arguments[1];if(options === void 0)options = {};

    this.declareMembers(['previous', 'operators']);

    if(!previous.type){ // no type, it's options
      this.extend(options, previous);
      previous = null;
    }

    this.operators = [];

    if(previous) {
      // add ourselves to the previous operator if its passed
      previous.add(this);
      this.previous = previous;
    }
  }DP$0(Lfp, "prototype", {"configurable": false, "enumerable": false, "writable": false});

  // sets all the members with there encapsulation properties in the instance
  Lfp.prototype.declareMembers = function() {var members = arguments[0];if(members === void 0)members = [];
    var that = this;
    members.forEach(function(member) {
      var accessors = {};
      
      if(isObject(member)){
        var key = Object.keys(member)[0];
        if(!member[key]) return;
        accessors = member[key];
        member = key;
      }

      accessors.writable = true; // always

      Object.defineProperty(that, member, accessors);
    });
  }

  // adds child node to the operators list
  Lfp.prototype.add = function(lfp){
    if(lfp) this.operators.push(lfp);
    return this.operators.length-1;
  }

  // removes all children node from the operators list
  Lfp.prototype.remove = function(){
    this.operators = [];
  }

  // calls alls the operators and passes them the data
  Lfp.prototype.nextOperators = function(time, data) {
    var operators = this.operators;
    for (var i = 0; i < operators.length; i++) {
      var op = operators[i]; // the next operator object
      if(op && op.process) op.process.call(op, time, data); // call the process with its own context
    }
  }

  // will delete itself from the parent node
  Lfp.prototype.destroy = function(){
    if(this.previous) this.previous.remove(this);
  }

;return Lfp;})();

Object.defineProperty(Lfp.prototype, 'extend', {value: _dereq_('extend')})

module.exports = Lfp;
},{"extend":3}],3:[function(_dereq_,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var undefined;

var isPlainObject = function isPlainObject(obj) {
	"use strict";
	if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval) {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	"use strict";
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === "boolean") {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if (typeof target !== "object" && typeof target !== "function" || target == undefined) {
			target = {};
	}

	for (; i < length; ++i) {
		// Only deal with non-null/undefined values
		if ((options = arguments[i]) != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}]},{},[1])
(1)
});